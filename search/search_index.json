{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ArmoniK Admin CLI.","text":"<p>This repository is part of the ArmoniK project. It provides a command-line tool to monitor and manage ArmoniK clusters.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#requirements","title":"Requirements","text":"<p>The CLI requires Python version 3.8 or newer. In order to install the ArmoniK CLI in an isolated environment, you must have python3-venv installed on your machine.</p> <pre><code>sudo apt update &amp;&amp; sudo apt install python3-venv\n</code></pre>"},{"location":"#install-from-source","title":"Install from source","text":"<p>To install the CLI from source, first clone this repository.</p> <pre><code>git clone git@github.com/aneoconsulting/ArmoniK.Admin.CLI.git\n</code></pre> <p>Navigate in the root directory</p> <pre><code>cd ArmoniK.Admin.CLI\n</code></pre> <p>Create and activate the virtual environment</p> <pre><code>python -m venv ./venv\nsource ./venv/bin/activate\n</code></pre> <p>Install the CLI in the environment you just created.</p> <pre><code>pip install .\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are always welcome!</p> <p>See CONTRIBUTING for ways to get started.</p>"},{"location":"code_docs_gen/","title":"Code Documentation","text":""},{"location":"code_docs_gen/#armonik_cli.cli","title":"<code>armonik_cli.cli</code>","text":""},{"location":"code_docs_gen/#armonik_cli.cli.cli","title":"<code>cli()</code>","text":"<p>ArmoniK CLI is a tool to monitor and manage ArmoniK clusters.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/cli.py</code> <pre><code>@click.group(name=\"armonik\", context_settings={\"help_option_names\": [\"-h\", \"--help\"]})\n@click.version_option(version=__version__, prog_name=\"armonik\")\ndef cli() -&gt; None:\n    \"\"\"\n    ArmoniK CLI is a tool to monitor and manage ArmoniK clusters.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"code_docs_gen/#core","title":"Core","text":""},{"location":"code_docs_gen/#exceptions","title":"Exceptions","text":""},{"location":"code_docs_gen/#armonik_cli.core.filters.SemanticError","title":"<code>armonik_cli.core.filters.SemanticError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised for semantic errors in filter expressions.</p> <p>Attributes:</p> Name Type Description <code>msg</code> <p>The error message describing the semantic issue.</p> <code>expr</code> <p>The filter expression where the error occurred.</p> <code>pos</code> <p>The position of the error in the expression (zero-based index).</p> <code>context</code> <p>A snippet of the expression showing the error in context.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>class SemanticError(Exception):\n    \"\"\"\n    Exception raised for semantic errors in filter expressions.\n\n    Attributes:\n        msg: The error message describing the semantic issue.\n        expr: The filter expression where the error occurred.\n        pos: The position of the error in the expression (zero-based index).\n        context: A snippet of the expression showing the error in context.\n    \"\"\"\n\n    def __init__(self, msg: str, expr: str, column: Optional[int] = None) -&gt; None:\n        super().__init__()\n        self.msg = msg\n        self.expr = expr\n        self.pos = column - 1 if column is not None else -1\n        self.context = self.get_context(80)\n\n    def get_context(self, span: int) -&gt; str:\n        \"\"\"\n        Generate a context string highlighting the error position in the expression.\n\n        Args:\n            span: The number of characters to show before and after the error.\n\n        Returns:\n            A formatted string showing the error context.\n        \"\"\"\n        start = max(self.pos - span, 0)\n        end = self.pos + span\n        before = self.expr[start : self.pos].rsplit(\"\\n\", 1)[-1]\n        after = self.expr[self.pos : end].split(\"\\n\", 1)[0]\n        return f\"\\n\\t{before}{after}\\n\\t\" + len(before.expandtabs()) * \" \" + \"^\\n\\n\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Generate a string representation of the semantic error.\n\n        Returns:\n            A detailed error message.\n        \"\"\"\n        message = \"Invalid filter expression.\\n\"\n        message += self.context\n        message += self.msg\n        return message\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.SemanticError.__str__","title":"<code>__str__()</code>","text":"<p>Generate a string representation of the semantic error.</p> <p>Returns:</p> Type Description <code>str</code> <p>A detailed error message.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Generate a string representation of the semantic error.\n\n    Returns:\n        A detailed error message.\n    \"\"\"\n    message = \"Invalid filter expression.\\n\"\n    message += self.context\n    message += self.msg\n    return message\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.SemanticError.get_context","title":"<code>get_context(span)</code>","text":"<p>Generate a context string highlighting the error position in the expression.</p> <p>Parameters:</p> Name Type Description Default <code>span</code> <code>int</code> <p>The number of characters to show before and after the error.</p> required <p>Returns:</p> Type Description <code>str</code> <p>A formatted string showing the error context.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def get_context(self, span: int) -&gt; str:\n    \"\"\"\n    Generate a context string highlighting the error position in the expression.\n\n    Args:\n        span: The number of characters to show before and after the error.\n\n    Returns:\n        A formatted string showing the error context.\n    \"\"\"\n    start = max(self.pos - span, 0)\n    end = self.pos + span\n    before = self.expr[start : self.pos].rsplit(\"\\n\", 1)[-1]\n    after = self.expr[self.pos : end].split(\"\\n\", 1)[0]\n    return f\"\\n\\t{before}{after}\\n\\t\" + len(before.expandtabs()) * \" \" + \"^\\n\\n\"\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.exceptions.ArmoniKCLIError","title":"<code>armonik_cli.exceptions.ArmoniKCLIError</code>","text":"<p>               Bases: <code>ClickException</code></p> <p>Base exception for ArmoniK CLI errors.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/exceptions.py</code> <pre><code>class ArmoniKCLIError(click.ClickException):\n    \"\"\"Base exception for ArmoniK CLI errors.\"\"\"\n\n    def __init__(self, message: str) -&gt; None:\n        super().__init__(message)\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.exceptions.InternalError","title":"<code>armonik_cli.exceptions.InternalError</code>","text":"<p>               Bases: <code>ArmoniKCLIError</code></p> <p>Error raised when an unknown internal error occured.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/exceptions.py</code> <pre><code>class InternalError(ArmoniKCLIError):\n    \"\"\"Error raised when an unknown internal error occured.\"\"\"\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.exceptions.InternalArmoniKError","title":"<code>armonik_cli.exceptions.InternalArmoniKError</code>","text":"<p>               Bases: <code>ArmoniKCLIError</code></p> <p>Error raised when there's an error in ArmoniK, you need to check the logs there for more information.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/exceptions.py</code> <pre><code>class InternalArmoniKError(ArmoniKCLIError):\n    \"\"\"Error raised when there's an error in ArmoniK, you need to check the logs there for more information.\"\"\"\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.exceptions.NotFoundError","title":"<code>armonik_cli.exceptions.NotFoundError</code>","text":"<p>               Bases: <code>ArmoniKCLIError</code></p> <p>Error raised when a given object of the API is not found.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/exceptions.py</code> <pre><code>class NotFoundError(ArmoniKCLIError):\n    \"\"\"Error raised when a given object of the API is not found.\"\"\"\n</code></pre>"},{"location":"code_docs_gen/#decorators","title":"Decorators","text":"<p>The error handler decorator is supposed to serve as the object where all errors that happen during command execution are routed to. It helps make said errors more presentable.</p> <p>Base command is a decorator that's used for all the commands in the ArmoniK CLI, it includes the error handler.</p>"},{"location":"code_docs_gen/#armonik_cli.core.decorators.error_handler","title":"<code>armonik_cli.core.decorators.error_handler(func=None)</code>","text":"<p>Decorator to ensure correct display of errors.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The command function to be decorated. If None, a partial function is returned, allowing the decorator to be used with parentheses.</p> <code>None</code> <p>Returns:</p> Type Description <p>The wrapped function with added CLI options.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/decorators.py</code> <pre><code>def error_handler(func=None):\n    \"\"\"Decorator to ensure correct display of errors.\n\n    Args:\n        func: The command function to be decorated. If None, a partial function is returned,\n            allowing the decorator to be used with parentheses.\n\n    Returns:\n        The wrapped function with added CLI options.\n    \"\"\"\n    # Allow to call the decorator with parenthesis.\n    if not func:\n        return partial(error_handler)\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except click.ClickException:\n            raise\n        except grpc.RpcError as err:\n            status_code = err.code()\n            error_details = f\"{err.details()}.\"\n\n            if status_code == grpc.StatusCode.NOT_FOUND:\n                raise NotFoundError(error_details)\n            elif status_code == grpc.StatusCode.INTERNAL:\n                raise InternalArmoniKError(f\"An internal exception has occured:\\n{error_details}\")\n            elif status_code == grpc.StatusCode.UNKNOWN:\n                raise InternalArmoniKError(f\"An unknown exception has occured:\\n{error_details}\")\n            else:\n                raise InternalError(\"An internal fatal error occured.\")\n        except Exception:\n            if \"debug\" in kwargs and kwargs[\"debug\"]:\n                console.print_exception()\n            else:\n                raise InternalError(\"An internal fatal error occured.\")\n\n    return wrapper\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.decorators.base_command","title":"<code>armonik_cli.core.decorators.base_command(func=None)</code>","text":"<p>Decorator to add common CLI options to a Click command function, including 'endpoint', 'output', and 'debug'. These options are automatically passed as arguments to the decorated function.</p> <p>The following options are added to the command: - <code>--endpoint</code> (required): Specifies the cluster endpoint. - <code>--output</code>: Sets the output format, with options 'yaml', 'json', or 'table' (default is 'json'). - <code>--debug</code>: Enables debug mode, printing additional logs if set.</p> Warning <p>If the decorated function has parameters with the same names as the options added by this decorator, this can lead to conflicts and unpredictable behavior.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <p>The command function to be decorated. If None, a partial function is returned, allowing the decorator to be used with parentheses.</p> <code>None</code> <p>Returns:</p> Type Description <p>The wrapped function with added CLI options.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/decorators.py</code> <pre><code>def base_command(func=None):\n    \"\"\"Decorator to add common CLI options to a Click command function, including\n    'endpoint', 'output', and 'debug'. These options are automatically passed\n    as arguments to the decorated function.\n\n    The following options are added to the command:\n    - `--endpoint` (required): Specifies the cluster endpoint.\n    - `--output`: Sets the output format, with options 'yaml', 'json', or 'table' (default is 'json').\n    - `--debug`: Enables debug mode, printing additional logs if set.\n\n    Warning:\n        If the decorated function has parameters with the same names as the options added by\n        this decorator, this can lead to conflicts and unpredictable behavior.\n\n    Args:\n        func: The command function to be decorated. If None, a partial function is returned,\n            allowing the decorator to be used with parentheses.\n\n    Returns:\n        The wrapped function with added CLI options.\n    \"\"\"\n\n    # Allow to call the decorator with parenthesis.\n    if not func:\n        return partial(base_command)\n\n    # Define the wrapper function with added Click options\n    @click.option(\n        \"-e\",\n        \"--endpoint\",\n        type=str,\n        required=True,\n        help=\"Endpoint of the cluster to connect to.\",\n        metavar=\"ENDPOINT\",\n    )\n    @click.option(\n        \"-o\",\n        \"--output\",\n        type=click.Choice([\"yaml\", \"json\", \"table\"], case_sensitive=False),\n        default=\"json\",\n        show_default=True,\n        help=\"Commands output format.\",\n        metavar=\"FORMAT\",\n    )\n    @click.option(\n        \"--debug\", is_flag=True, default=False, help=\"Print debug logs and internal errors.\"\n    )\n    @error_handler\n    @wraps(func)\n    def wrapper(endpoint: str, output: str, debug: bool, *args, **kwargs):\n        kwargs[\"endpoint\"] = endpoint\n        kwargs[\"output\"] = output\n        kwargs[\"debug\"] = debug\n        return func(*args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"code_docs_gen/#options","title":"Options","text":"<p>We've created some custom options that simplify the task of writing certain commands. </p>"},{"location":"code_docs_gen/#armonik_cli.core.options.MutuallyExclusiveOption","title":"<code>armonik_cli.core.options.MutuallyExclusiveOption</code>","text":"<p>               Bases: <code>Option</code></p> <p>A custom Click option class that enforces mutual exclusivity between specified options and optionally requires at least one of the mutual options to be passed.</p> <p>Attributes:</p> Name Type Description <code>mutual</code> <p>A list of option names that cannot be used together with this option.</p> <code>require_one</code> <p>Whether at least one of the mutually exclusive options must be provided.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/options.py</code> <pre><code>class MutuallyExclusiveOption(click.Option):\n    \"\"\"\n    A custom Click option class that enforces mutual exclusivity between specified options\n    and optionally requires at least one of the mutual options to be passed.\n\n    Attributes:\n        mutual: A list of option names that cannot be used together with this option.\n        require_one: Whether at least one of the mutually exclusive options must be provided.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        self.mutual = set(kwargs.pop(\"mutual\", []))\n        self.require_one = kwargs.pop(\"require_one\", False)\n\n        if self.mutual:\n            mutual_text = f\" This option cannot be used together with {' or '.join(self.mutual)}.\"\n            kwargs[\"help\"] = f\"{kwargs.get('help', '')}{mutual_text}\"\n\n        if self.require_one:\n            kwargs[\"help\"] = (\n                f\"{kwargs.get('help', '')} At least one of these options must be provided.\"\n            )\n\n        super().__init__(*args, **kwargs)\n\n    def handle_parse_result(\n        self, ctx: click.Context, opts: Mapping[str, Any], args: List[str]\n    ) -&gt; Tuple[Any, List[str]]:\n        \"\"\"\n        Handle the parsing of command-line options, enforcing mutual exclusivity\n        and the requirement of at least one mutual option if specified.\n\n        Args:\n            ctx: The Click context.\n            opts: A dictionary of the parsed command-line options.\n            args: The remaining command-line arguments.\n\n        Returns:\n            The result of the superclass's `handle_parse_result` method.\n\n        Raises:\n            click.UsageError: If mutual exclusivity is violated or if none of the required options are provided.\n        \"\"\"\n        mutex = self.mutual.intersection(opts)\n\n        # Enforce mutual exclusivity\n        if mutex and self.name in opts:\n            raise click.UsageError(\n                f\"Illegal usage: `{self.name}` cannot be used together with '{', '.join(mutex)}'.\"\n            )\n\n        # Enforce that at least one mutual option is provided\n        if self.require_one and not mutex and self.name not in opts:\n            raise click.UsageError(\n                f\"At least one of the following options must be provided: {', '.join(self.mutual)}.\"\n            )\n\n        return super().handle_parse_result(ctx, opts, args)\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.options.MutuallyExclusiveOption.handle_parse_result","title":"<code>handle_parse_result(ctx, opts, args)</code>","text":"<p>Handle the parsing of command-line options, enforcing mutual exclusivity and the requirement of at least one mutual option if specified.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The Click context.</p> required <code>opts</code> <code>Mapping[str, Any]</code> <p>A dictionary of the parsed command-line options.</p> required <code>args</code> <code>List[str]</code> <p>The remaining command-line arguments.</p> required <p>Returns:</p> Type Description <code>Tuple[Any, List[str]]</code> <p>The result of the superclass's <code>handle_parse_result</code> method.</p> <p>Raises:</p> Type Description <code>UsageError</code> <p>If mutual exclusivity is violated or if none of the required options are provided.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/options.py</code> <pre><code>def handle_parse_result(\n    self, ctx: click.Context, opts: Mapping[str, Any], args: List[str]\n) -&gt; Tuple[Any, List[str]]:\n    \"\"\"\n    Handle the parsing of command-line options, enforcing mutual exclusivity\n    and the requirement of at least one mutual option if specified.\n\n    Args:\n        ctx: The Click context.\n        opts: A dictionary of the parsed command-line options.\n        args: The remaining command-line arguments.\n\n    Returns:\n        The result of the superclass's `handle_parse_result` method.\n\n    Raises:\n        click.UsageError: If mutual exclusivity is violated or if none of the required options are provided.\n    \"\"\"\n    mutex = self.mutual.intersection(opts)\n\n    # Enforce mutual exclusivity\n    if mutex and self.name in opts:\n        raise click.UsageError(\n            f\"Illegal usage: `{self.name}` cannot be used together with '{', '.join(mutex)}'.\"\n        )\n\n    # Enforce that at least one mutual option is provided\n    if self.require_one and not mutex and self.name not in opts:\n        raise click.UsageError(\n            f\"At least one of the following options must be provided: {', '.join(self.mutual)}.\"\n        )\n\n    return super().handle_parse_result(ctx, opts, args)\n</code></pre>"},{"location":"code_docs_gen/#filters","title":"Filters","text":"<p>The following classes are used for a custom Click parameter type that allows you to filter ArmoniK's objects based on specific conditions. </p>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterParser","title":"<code>armonik_cli.core.filters.FilterParser</code>","text":"<p>A parser for processing and validating filter expressions.</p> <p>Attributes:</p> Name Type Description <code>obj</code> <p>The ArmoniK API object associated with the filter.</p> <code>filter</code> <p>The ArmoniK API filter corresponding to the object.</p> <code>status_enum</code> <p>The enumeration for the object's status, if applicable.</p> <code>options_fields</code> <p>Whether to allow filtering by options fields (e.g., TaskOptions).</p> <code>output_fields</code> <p>Whether to allow filtering by output fields for Task filters.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>class FilterParser:\n    \"\"\"\n    A parser for processing and validating filter expressions.\n\n    Attributes:\n        obj: The ArmoniK API object associated with the filter.\n        filter: The ArmoniK API filter corresponding to the object.\n        status_enum: The enumeration for the object's status, if applicable.\n        options_fields: Whether to allow filtering by options fields (e.g., TaskOptions).\n        output_fields: Whether to allow filtering by output fields for Task filters.\n    \"\"\"\n\n    _grammar_file = Path(__file__).parent / \"filter_grammar.lark\"\n\n    def __init__(\n        self,\n        obj: Union[Partition, Result, Session, Task],\n        filter: Union[PartitionFilter, ResultFilter, SessionFilter, TaskFilter],\n        status_enum: Optional[Union[ResultStatus, SessionStatus, TaskStatus, None]] = None,\n        options_fields: bool = False,\n        output_fields: bool = False,\n    ) -&gt; None:\n        self.obj = obj\n        self.filter = filter\n        self.status_enum = status_enum\n        self.options_fields = options_fields\n        self.output_fields = output_fields\n\n    @classmethod\n    def get_parser(cls) -&gt; Lark:\n        \"\"\"\n        Generate a Lark parser for the grammar associated with the filter.\n\n        Returns:\n            A Lark parser instance.\n        \"\"\"\n        with cls._grammar_file.open() as file:\n            grammar = file.read()\n            return Lark(grammar, start=\"start\", parser=\"earley\")\n\n    def parse(self, expression: str) -&gt; Filter:\n        \"\"\"\n        Parse a filter expression into a Filter object.\n\n        Args:\n            expression: The filter expression as a string.\n\n        Returns:\n            A Filter object constructed from the parsed expression.\n        \"\"\"\n        tree = self.get_parser().parse(expression)\n        filter = FilterTransformer(\n            obj=self.obj,\n            filter=self.filter,\n            status_enum=self.status_enum,\n            options_fields=self.options_fields,\n            output_fields=self.output_fields,\n            expr=expression,\n        ).transform(tree)\n        return filter\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterParser.get_parser","title":"<code>get_parser()</code>  <code>classmethod</code>","text":"<p>Generate a Lark parser for the grammar associated with the filter.</p> <p>Returns:</p> Type Description <code>Lark</code> <p>A Lark parser instance.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>@classmethod\ndef get_parser(cls) -&gt; Lark:\n    \"\"\"\n    Generate a Lark parser for the grammar associated with the filter.\n\n    Returns:\n        A Lark parser instance.\n    \"\"\"\n    with cls._grammar_file.open() as file:\n        grammar = file.read()\n        return Lark(grammar, start=\"start\", parser=\"earley\")\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterParser.parse","title":"<code>parse(expression)</code>","text":"<p>Parse a filter expression into a Filter object.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>str</code> <p>The filter expression as a string.</p> required <p>Returns:</p> Type Description <code>Filter</code> <p>A Filter object constructed from the parsed expression.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def parse(self, expression: str) -&gt; Filter:\n    \"\"\"\n    Parse a filter expression into a Filter object.\n\n    Args:\n        expression: The filter expression as a string.\n\n    Returns:\n        A Filter object constructed from the parsed expression.\n    \"\"\"\n    tree = self.get_parser().parse(expression)\n    filter = FilterTransformer(\n        obj=self.obj,\n        filter=self.filter,\n        status_enum=self.status_enum,\n        options_fields=self.options_fields,\n        output_fields=self.output_fields,\n        expr=expression,\n    ).transform(tree)\n    return filter\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterTransformer","title":"<code>armonik_cli.core.filters.FilterTransformer</code>","text":"<p>               Bases: <code>Transformer</code></p> <p>A transformer to convert parsed filter expressions into Filter objects.</p> <p>Attributes:</p> Name Type Description <code>obj</code> <p>The ArmoniK API object associated with the filter.</p> <code>filter</code> <p>The ArmoniK API filter corresponding to the object.</p> <code>status_enum</code> <p>The object status enumeration.</p> <code>options_fields</code> <p>Whether options fields are allowed in the filter.</p> <code>output_fields</code> <p>Whether output fields are allowed in the filter.</p> <code>expr</code> <code>Filter</code> <p>The original filter expression.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>class FilterTransformer(Transformer):\n    \"\"\"\n    A transformer to convert parsed filter expressions into Filter objects.\n\n    Attributes:\n        obj: The ArmoniK API object associated with the filter.\n        filter: The ArmoniK API filter corresponding to the object.\n        status_enum: The object status enumeration.\n        options_fields: Whether options fields are allowed in the filter.\n        output_fields: Whether output fields are allowed in the filter.\n        expr: The original filter expression.\n    \"\"\"\n\n    def __init__(\n        self,\n        obj: Union[Partition, Result, Session, Task],\n        filter: Union[PartitionFilter, ResultFilter, SessionFilter, TaskFilter],\n        expr: str,\n        status_enum: Optional[Union[ResultStatus, SessionStatus, TaskStatus, None]] = None,\n        options_fields: bool = False,\n        output_fields: bool = False,\n    ) -&gt; None:\n        super().__init__(visit_tokens=True)\n        self._obj = obj\n        self._filter = filter\n        self._status_enum = status_enum\n        self._expr = expr\n        self._options_fields = options_fields\n        self._output_fields = output_fields\n\n    def expr(self, args: List[Union[Filter, Token]]) -&gt; Filter:\n        \"\"\"\n        Combine multiple filter expressions using logical OR.\n\n        Args:\n            args: A list of filters and OR tokens.\n\n        Returns:\n            The combined filter expression.\n        \"\"\"\n        return reduce(operator.or_, [item for item in args if not isinstance(item, Token)])\n\n    def term(self, args: List[Union[Filter, Token]]) -&gt; Filter:\n        \"\"\"\n        Combine multiple filter expressions using logical AND.\n\n        Args:\n            args: A list of filters and AND tokens.\n\n        Returns:\n            The combined filter expression.\n        \"\"\"\n        return reduce(operator.and_, [item for item in args if not isinstance(item, Token)])\n\n    def factor(self, args: List[Union[Filter, Token]]) -&gt; Filter:\n        \"\"\"\n        Process a single filter or its negation.\n\n        Args:\n            args: A list containing a single filter and an optional token for its negation.\n\n        Returns:\n            The processed filter.\n        \"\"\"\n        if len(args) == 1:\n            return args[0]\n        elif len(args) == 2:\n            return -cast(Filter, args[1])\n        msg = f\"Unexpected token sequence: {args}.\"\n        raise ValueError(msg)\n\n    def comparison(self, args: List[Token]) -&gt; Filter:\n        \"\"\"\n        Process a comparison expression.\n\n        Args:\n            args: Tokens representing the comparison (field, operator, value).\n\n        Returns:\n            The resulting filter.\n        \"\"\"\n        if len(args) != 3:\n            msg = f\"Unexpected token sequence: {args}.\"\n            raise ValueError(msg)\n        _, filter = args[0].value\n        op: Callable[[Filter, Any], Filter] = args[1].value\n        value: str = args[2].value\n\n        try:\n            if isinstance(filter, StatusFilter):\n                value = getattr(self._status_enum, value.upper())\n            return op(filter, value)\n        except FilterError as error:\n            if error.message.startswith(\"Operator\"):\n                tok = args[1]\n            elif error.message.startswith(\"Expected value type\"):\n                tok = args[2]\n            else:\n                tok = args[0]\n            raise SemanticError(\n                msg=error.message,\n                expr=self._expr,\n                column=tok.column,\n            )\n        except AttributeError:\n            msg = f\"{self._obj.__name__.lower()} has no status '{value}'.\"\n            raise SemanticError(\n                msg=msg,\n                expr=self._expr,\n                column=args[2].column,\n            )\n        except AttributeError:\n            msg = f\"{self._obj.__name__.lower()} has no status '{value}'.\"\n            raise SemanticError(\n                msg=msg,\n                expr=self._expr,\n                column=args[2].column,\n            )\n\n    def test(self, args: List[Token]) -&gt; BooleanFilter:\n        \"\"\"\n        Process a test expression.\n\n        Args:\n            args: A list of tokens containing the field and filter data.\n\n        Returns:\n            The boolean filter extracted from the token.\n\n        Raises:\n            SemanticError: If the field's filter is not a boolean field.\n            ValueError: If an unexpected token sequence is provided.\n        \"\"\"\n        if len(args) == 1:\n            field, filter = args[0].value\n            if isinstance(filter, BooleanFilter):\n                return filter\n            msg = f\"{self._obj.__name__.capitalize()} filter's '{field}' field is not a boolean field.\"\n            raise SemanticError(\n                msg=msg,\n                expr=self._expr,\n                column=args[0].column,\n            )\n        msg = f\"Unexcepted token sequence: {args}.\"\n        raise ValueError(msg)\n\n    def identifier(self, args: List[Token]) -&gt; Token:\n        \"\"\"\n        Resolves and validates an identifier token, updating its value based on field type.\n\n        Args:\n            args: A list of tokens containing identifier details.\n\n        Returns:\n            The updated token with resolved field information.\n\n        Raises:\n            SemanticError: If the field is invalid or unsupported.\n            ValueError: If an unexpected token sequence is provided.\n        \"\"\"\n        if len(args) == 1:\n            field = args[0].value\n            if field.startswith(\"options.\"):\n                option_field = field[8:]\n                if not self._options_fields:\n                    msg = f\"{self._obj.__name__.capitalize()} fillers don't have options fields.\"\n                    raise SemanticError(\n                        msg=msg,\n                        expr=self._expr,\n                        column=args[0].column,\n                    )\n                if (\n                    option_field not in TaskOptionFilter._fields\n                    or TaskOptionFilter._fields[option_field][0] == FType.NA\n                    or TaskOptionFilter._fields[option_field][0] == FType.UNKNOWN\n                ):\n                    msg = f\"{self._obj.__name__.capitalize()} fillers don't have a field '{option_field}' in the option fields.\"\n                    raise SemanticError(\n                        msg=msg,\n                        expr=self._expr,\n                        column=args[0].column,\n                    )\n                return args[0].update(value=(field, getattr(self._obj.options, option_field)))\n            elif field.startswith(\"output.\"):\n                output_field = field[7:]\n                if not self._output_fields:\n                    msg = f\"{self._obj.__name__.capitalize()} fillers don't have output fields.\"\n                    raise SemanticError(\n                        msg=msg,\n                        expr=self._expr,\n                        column=args[0].column,\n                    )\n                if output_field != \"error\":\n                    msg = f\"{self._obj.__name__.capitalize()} fillers don't have a field '{output_field}' in the output fields.\"\n                    raise SemanticError(\n                        msg=msg,\n                        expr=self._expr,\n                        column=args[0].column,\n                    )\n                return args[0].update(value=(field, getattr(self._obj.output, output_field)))\n            if (\n                field not in self._filter._fields\n                or self._filter._fields[field][0] == FType.NA\n                or self._filter._fields[field][0] == FType.UNKNOWN\n            ):\n                msg = f\"{self._obj.__name__.capitalize()} filters don't have a field '{field}'.\"\n                raise SemanticError(\n                    msg=msg,\n                    expr=self._expr,\n                    column=args[0].column,\n                )\n            return args[0].update(value=(field, getattr(self._obj, field)))\n        elif len(args) == 3:\n            key = args[1].value\n            if not self._options_fields:\n                msg = f\"{self._obj.__name__.capitalize()} fillers have no options fields and therefore no custom option fields..\"\n                raise SemanticError(\n                    msg=msg,\n                    expr=self._expr,\n                    column=args[0].column,\n                )\n            return args[1].update(value=(f\"option['{key}']\", self._obj.options[key]))\n        msg = f\"Unexcepted token sequence: {args}.\"\n        raise ValueError(msg)\n\n    def STRING(self, tok: Token) -&gt; Token:\n        \"\"\"\n        Processes a STRING token by removing delimiters.\n\n        Args:\n            tok: A STRING token.\n\n        Returns:\n            The updated token with delimiters removed.\n        \"\"\"\n        return tok.update(value=remove_string_delimiters(tok.value))\n\n    def SIGNED_NUMBER(self, tok: Token) -&gt; Token:\n        \"\"\"\n        Converts a SIGNED_NUMBER token to an integer.\n\n        Args:\n            tok: A SIGNED_NUMBER token.\n\n        Returns:\n            The updated token with an integer value.\n        \"\"\"\n        return tok.update(value=int(tok.value))\n\n    def DATETIME(self, tok: Token) -&gt; Token:\n        \"\"\"\n        Parses a DATETIME token into a Python datetime object.\n\n        Args:\n            tok: A DATETIME token.\n\n        Returns:\n            The updated token with a datetime value.\n        \"\"\"\n        return tok.update(\n            value=datetime.strptime(\n                tok.value, \"%Y-%m-%dT%H:%M:%S\" if \"T\" in tok.value else \"%Y-%m-%d\"\n            )\n        )\n\n    def DURATION(self, tok: Token) -&gt; Token:\n        \"\"\"\n        Parses a DURATION token into a timedelta object.\n\n        Args:\n            tok: A DURATION token.\n\n        Returns:\n            The updated token with a timedelta value.\n        \"\"\"\n        return tok.update(value=parse_time_delta(tok.value))\n\n    def EQ(self, tok: Token) -&gt; Token:\n        \"\"\"\n        Maps an EQ token to the equality operator.\n\n        Args:\n            tok: An EQ token.\n\n        Returns:\n            The updated token with the equality operator.\n        \"\"\"\n        return tok.update(value=operator.eq)\n\n    def NEQ(self, tok: Token) -&gt; Token:\n        \"\"\"\n        Maps an EQ token to the unequality operator.\n\n        Args:\n            tok: An NEQ token.\n\n        Returns:\n            The updated token with the unequality operator.\n        \"\"\"\n        return tok.update(value=operator.ne)\n\n    def LT(self, tok: Token) -&gt; Token:\n        \"\"\"\n        Maps an LT token to the lower than operator.\n\n        Args:\n            tok: An LT token.\n\n        Returns:\n            The updated token with the lower than operator.\n        \"\"\"\n        return tok.update(value=operator.lt)\n\n    def LTE(self, tok: Token) -&gt; Token:\n        \"\"\"\n        Maps an LTE token to the lower than or equal operator.\n\n        Args:\n            tok: An LTE token.\n\n        Returns:\n            The updated token with the lower than or equal operator.\n        \"\"\"\n        return tok.update(value=operator.le)\n\n    def GT(self, tok: Token) -&gt; Token:\n        \"\"\"\n        Maps an GT token to the greater than operator.\n\n        Args:\n            tok: An GT token.\n\n        Returns:\n            The updated token with the greater than operator.\n        \"\"\"\n        return tok.update(value=operator.gt)\n\n    def GTE(self, tok: Token) -&gt; Token:\n        \"\"\"\n        Maps an GTE token to the greater than or equal operator.\n\n        Args:\n            tok: An GTE token.\n\n        Returns:\n            The updated token with the greater than or equal operator.\n        \"\"\"\n        return tok.update(value=operator.ge)\n\n    def CONTAINS(self, tok: Token) -&gt; Token:\n        \"\"\"\n        Maps an CONTAINS token to a contains operator.\n\n        Args:\n            tok: An CONTAINS token.\n\n        Returns:\n            The updated token with a function mimicking the contains operator.\n        \"\"\"\n\n        def contains_func(filter: StringFilter, substr: str) -&gt; BooleanFilter:\n            return filter.contains(substr)\n\n        return tok.update(value=contains_func)\n\n    def NOTCONTAINS(self, tok: Token) -&gt; Token:\n        \"\"\"\n        Maps an NOTCONTAINS token to a not contains operator.\n\n        Args:\n            tok: An EQ token.\n\n        Returns:\n            The updated token with a function mimicking the not contains operator\n        \"\"\"\n\n        def notcontains_func(filter: StringFilter, substr: str) -&gt; BooleanFilter:\n            return -filter.contains(substr)\n\n        return tok.update(value=notcontains_func)\n\n    def STARTSWITH(self, tok: Token) -&gt; Token:\n        \"\"\"\n        Maps an STARTSWITH token to a starts with operator.\n\n        Args:\n            tok: An STARTSWITH token.\n\n        Returns:\n            The updated token with a function mimicking the starts with operator\n        \"\"\"\n\n        def startswith_func(filter: StringFilter, prefix: str) -&gt; BooleanFilter:\n            return filter.startswith(prefix)\n\n        return tok.update(value=startswith_func)\n\n    def ENDSWIDTH(self, tok: Token) -&gt; Token:\n        \"\"\"\n        Maps an ENDSWITH token to the ends with operator.\n\n        Args:\n            tok: An ENDSWITH token.\n\n        Returns:\n            The updated token with a function mimicking the ends with operator\n        \"\"\"\n\n        def endswith_func(filter: StringFilter, suffix: str) -&gt; BooleanFilter:\n            return filter.endswith(suffix)\n\n        return tok.update(value=endswith_func)\n\n    def IS(self, tok: Token) -&gt; Token:\n        \"\"\"\n        Processes an IS token to evaluate a boolean filter.\n\n        Args:\n            tok: An IS token.\n\n        Returns:\n            The updated token with a function for boolean evaluation.\n        \"\"\"\n\n        def is_func(filter: BooleanFilter, bool_str: str) -&gt; BooleanFilter:\n            if bool_str.lower() == \"true\":\n                return filter\n            elif bool_str.lower() == \"false\":\n                return -filter\n            else:\n                msg = f\"Invalid value for boolean field: {bool_str}.\"\n                raise SemanticError(\n                    msg=msg,\n                    expr=self._expr,\n                    column=tok.column,\n                )\n\n        return tok.update(value=is_func)\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterTransformer.CONTAINS","title":"<code>CONTAINS(tok)</code>","text":"<p>Maps an CONTAINS token to a contains operator.</p> <p>Parameters:</p> Name Type Description Default <code>tok</code> <code>Token</code> <p>An CONTAINS token.</p> required <p>Returns:</p> Type Description <code>Token</code> <p>The updated token with a function mimicking the contains operator.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def CONTAINS(self, tok: Token) -&gt; Token:\n    \"\"\"\n    Maps an CONTAINS token to a contains operator.\n\n    Args:\n        tok: An CONTAINS token.\n\n    Returns:\n        The updated token with a function mimicking the contains operator.\n    \"\"\"\n\n    def contains_func(filter: StringFilter, substr: str) -&gt; BooleanFilter:\n        return filter.contains(substr)\n\n    return tok.update(value=contains_func)\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterTransformer.DATETIME","title":"<code>DATETIME(tok)</code>","text":"<p>Parses a DATETIME token into a Python datetime object.</p> <p>Parameters:</p> Name Type Description Default <code>tok</code> <code>Token</code> <p>A DATETIME token.</p> required <p>Returns:</p> Type Description <code>Token</code> <p>The updated token with a datetime value.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def DATETIME(self, tok: Token) -&gt; Token:\n    \"\"\"\n    Parses a DATETIME token into a Python datetime object.\n\n    Args:\n        tok: A DATETIME token.\n\n    Returns:\n        The updated token with a datetime value.\n    \"\"\"\n    return tok.update(\n        value=datetime.strptime(\n            tok.value, \"%Y-%m-%dT%H:%M:%S\" if \"T\" in tok.value else \"%Y-%m-%d\"\n        )\n    )\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterTransformer.DURATION","title":"<code>DURATION(tok)</code>","text":"<p>Parses a DURATION token into a timedelta object.</p> <p>Parameters:</p> Name Type Description Default <code>tok</code> <code>Token</code> <p>A DURATION token.</p> required <p>Returns:</p> Type Description <code>Token</code> <p>The updated token with a timedelta value.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def DURATION(self, tok: Token) -&gt; Token:\n    \"\"\"\n    Parses a DURATION token into a timedelta object.\n\n    Args:\n        tok: A DURATION token.\n\n    Returns:\n        The updated token with a timedelta value.\n    \"\"\"\n    return tok.update(value=parse_time_delta(tok.value))\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterTransformer.ENDSWIDTH","title":"<code>ENDSWIDTH(tok)</code>","text":"<p>Maps an ENDSWITH token to the ends with operator.</p> <p>Parameters:</p> Name Type Description Default <code>tok</code> <code>Token</code> <p>An ENDSWITH token.</p> required <p>Returns:</p> Type Description <code>Token</code> <p>The updated token with a function mimicking the ends with operator</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def ENDSWIDTH(self, tok: Token) -&gt; Token:\n    \"\"\"\n    Maps an ENDSWITH token to the ends with operator.\n\n    Args:\n        tok: An ENDSWITH token.\n\n    Returns:\n        The updated token with a function mimicking the ends with operator\n    \"\"\"\n\n    def endswith_func(filter: StringFilter, suffix: str) -&gt; BooleanFilter:\n        return filter.endswith(suffix)\n\n    return tok.update(value=endswith_func)\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterTransformer.EQ","title":"<code>EQ(tok)</code>","text":"<p>Maps an EQ token to the equality operator.</p> <p>Parameters:</p> Name Type Description Default <code>tok</code> <code>Token</code> <p>An EQ token.</p> required <p>Returns:</p> Type Description <code>Token</code> <p>The updated token with the equality operator.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def EQ(self, tok: Token) -&gt; Token:\n    \"\"\"\n    Maps an EQ token to the equality operator.\n\n    Args:\n        tok: An EQ token.\n\n    Returns:\n        The updated token with the equality operator.\n    \"\"\"\n    return tok.update(value=operator.eq)\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterTransformer.GT","title":"<code>GT(tok)</code>","text":"<p>Maps an GT token to the greater than operator.</p> <p>Parameters:</p> Name Type Description Default <code>tok</code> <code>Token</code> <p>An GT token.</p> required <p>Returns:</p> Type Description <code>Token</code> <p>The updated token with the greater than operator.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def GT(self, tok: Token) -&gt; Token:\n    \"\"\"\n    Maps an GT token to the greater than operator.\n\n    Args:\n        tok: An GT token.\n\n    Returns:\n        The updated token with the greater than operator.\n    \"\"\"\n    return tok.update(value=operator.gt)\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterTransformer.GTE","title":"<code>GTE(tok)</code>","text":"<p>Maps an GTE token to the greater than or equal operator.</p> <p>Parameters:</p> Name Type Description Default <code>tok</code> <code>Token</code> <p>An GTE token.</p> required <p>Returns:</p> Type Description <code>Token</code> <p>The updated token with the greater than or equal operator.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def GTE(self, tok: Token) -&gt; Token:\n    \"\"\"\n    Maps an GTE token to the greater than or equal operator.\n\n    Args:\n        tok: An GTE token.\n\n    Returns:\n        The updated token with the greater than or equal operator.\n    \"\"\"\n    return tok.update(value=operator.ge)\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterTransformer.IS","title":"<code>IS(tok)</code>","text":"<p>Processes an IS token to evaluate a boolean filter.</p> <p>Parameters:</p> Name Type Description Default <code>tok</code> <code>Token</code> <p>An IS token.</p> required <p>Returns:</p> Type Description <code>Token</code> <p>The updated token with a function for boolean evaluation.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def IS(self, tok: Token) -&gt; Token:\n    \"\"\"\n    Processes an IS token to evaluate a boolean filter.\n\n    Args:\n        tok: An IS token.\n\n    Returns:\n        The updated token with a function for boolean evaluation.\n    \"\"\"\n\n    def is_func(filter: BooleanFilter, bool_str: str) -&gt; BooleanFilter:\n        if bool_str.lower() == \"true\":\n            return filter\n        elif bool_str.lower() == \"false\":\n            return -filter\n        else:\n            msg = f\"Invalid value for boolean field: {bool_str}.\"\n            raise SemanticError(\n                msg=msg,\n                expr=self._expr,\n                column=tok.column,\n            )\n\n    return tok.update(value=is_func)\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterTransformer.LT","title":"<code>LT(tok)</code>","text":"<p>Maps an LT token to the lower than operator.</p> <p>Parameters:</p> Name Type Description Default <code>tok</code> <code>Token</code> <p>An LT token.</p> required <p>Returns:</p> Type Description <code>Token</code> <p>The updated token with the lower than operator.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def LT(self, tok: Token) -&gt; Token:\n    \"\"\"\n    Maps an LT token to the lower than operator.\n\n    Args:\n        tok: An LT token.\n\n    Returns:\n        The updated token with the lower than operator.\n    \"\"\"\n    return tok.update(value=operator.lt)\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterTransformer.LTE","title":"<code>LTE(tok)</code>","text":"<p>Maps an LTE token to the lower than or equal operator.</p> <p>Parameters:</p> Name Type Description Default <code>tok</code> <code>Token</code> <p>An LTE token.</p> required <p>Returns:</p> Type Description <code>Token</code> <p>The updated token with the lower than or equal operator.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def LTE(self, tok: Token) -&gt; Token:\n    \"\"\"\n    Maps an LTE token to the lower than or equal operator.\n\n    Args:\n        tok: An LTE token.\n\n    Returns:\n        The updated token with the lower than or equal operator.\n    \"\"\"\n    return tok.update(value=operator.le)\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterTransformer.NEQ","title":"<code>NEQ(tok)</code>","text":"<p>Maps an EQ token to the unequality operator.</p> <p>Parameters:</p> Name Type Description Default <code>tok</code> <code>Token</code> <p>An NEQ token.</p> required <p>Returns:</p> Type Description <code>Token</code> <p>The updated token with the unequality operator.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def NEQ(self, tok: Token) -&gt; Token:\n    \"\"\"\n    Maps an EQ token to the unequality operator.\n\n    Args:\n        tok: An NEQ token.\n\n    Returns:\n        The updated token with the unequality operator.\n    \"\"\"\n    return tok.update(value=operator.ne)\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterTransformer.NOTCONTAINS","title":"<code>NOTCONTAINS(tok)</code>","text":"<p>Maps an NOTCONTAINS token to a not contains operator.</p> <p>Parameters:</p> Name Type Description Default <code>tok</code> <code>Token</code> <p>An EQ token.</p> required <p>Returns:</p> Type Description <code>Token</code> <p>The updated token with a function mimicking the not contains operator</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def NOTCONTAINS(self, tok: Token) -&gt; Token:\n    \"\"\"\n    Maps an NOTCONTAINS token to a not contains operator.\n\n    Args:\n        tok: An EQ token.\n\n    Returns:\n        The updated token with a function mimicking the not contains operator\n    \"\"\"\n\n    def notcontains_func(filter: StringFilter, substr: str) -&gt; BooleanFilter:\n        return -filter.contains(substr)\n\n    return tok.update(value=notcontains_func)\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterTransformer.SIGNED_NUMBER","title":"<code>SIGNED_NUMBER(tok)</code>","text":"<p>Converts a SIGNED_NUMBER token to an integer.</p> <p>Parameters:</p> Name Type Description Default <code>tok</code> <code>Token</code> <p>A SIGNED_NUMBER token.</p> required <p>Returns:</p> Type Description <code>Token</code> <p>The updated token with an integer value.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def SIGNED_NUMBER(self, tok: Token) -&gt; Token:\n    \"\"\"\n    Converts a SIGNED_NUMBER token to an integer.\n\n    Args:\n        tok: A SIGNED_NUMBER token.\n\n    Returns:\n        The updated token with an integer value.\n    \"\"\"\n    return tok.update(value=int(tok.value))\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterTransformer.STARTSWITH","title":"<code>STARTSWITH(tok)</code>","text":"<p>Maps an STARTSWITH token to a starts with operator.</p> <p>Parameters:</p> Name Type Description Default <code>tok</code> <code>Token</code> <p>An STARTSWITH token.</p> required <p>Returns:</p> Type Description <code>Token</code> <p>The updated token with a function mimicking the starts with operator</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def STARTSWITH(self, tok: Token) -&gt; Token:\n    \"\"\"\n    Maps an STARTSWITH token to a starts with operator.\n\n    Args:\n        tok: An STARTSWITH token.\n\n    Returns:\n        The updated token with a function mimicking the starts with operator\n    \"\"\"\n\n    def startswith_func(filter: StringFilter, prefix: str) -&gt; BooleanFilter:\n        return filter.startswith(prefix)\n\n    return tok.update(value=startswith_func)\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterTransformer.STRING","title":"<code>STRING(tok)</code>","text":"<p>Processes a STRING token by removing delimiters.</p> <p>Parameters:</p> Name Type Description Default <code>tok</code> <code>Token</code> <p>A STRING token.</p> required <p>Returns:</p> Type Description <code>Token</code> <p>The updated token with delimiters removed.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def STRING(self, tok: Token) -&gt; Token:\n    \"\"\"\n    Processes a STRING token by removing delimiters.\n\n    Args:\n        tok: A STRING token.\n\n    Returns:\n        The updated token with delimiters removed.\n    \"\"\"\n    return tok.update(value=remove_string_delimiters(tok.value))\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterTransformer.comparison","title":"<code>comparison(args)</code>","text":"<p>Process a comparison expression.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>List[Token]</code> <p>Tokens representing the comparison (field, operator, value).</p> required <p>Returns:</p> Type Description <code>Filter</code> <p>The resulting filter.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def comparison(self, args: List[Token]) -&gt; Filter:\n    \"\"\"\n    Process a comparison expression.\n\n    Args:\n        args: Tokens representing the comparison (field, operator, value).\n\n    Returns:\n        The resulting filter.\n    \"\"\"\n    if len(args) != 3:\n        msg = f\"Unexpected token sequence: {args}.\"\n        raise ValueError(msg)\n    _, filter = args[0].value\n    op: Callable[[Filter, Any], Filter] = args[1].value\n    value: str = args[2].value\n\n    try:\n        if isinstance(filter, StatusFilter):\n            value = getattr(self._status_enum, value.upper())\n        return op(filter, value)\n    except FilterError as error:\n        if error.message.startswith(\"Operator\"):\n            tok = args[1]\n        elif error.message.startswith(\"Expected value type\"):\n            tok = args[2]\n        else:\n            tok = args[0]\n        raise SemanticError(\n            msg=error.message,\n            expr=self._expr,\n            column=tok.column,\n        )\n    except AttributeError:\n        msg = f\"{self._obj.__name__.lower()} has no status '{value}'.\"\n        raise SemanticError(\n            msg=msg,\n            expr=self._expr,\n            column=args[2].column,\n        )\n    except AttributeError:\n        msg = f\"{self._obj.__name__.lower()} has no status '{value}'.\"\n        raise SemanticError(\n            msg=msg,\n            expr=self._expr,\n            column=args[2].column,\n        )\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterTransformer.expr","title":"<code>expr(args)</code>","text":"<p>Combine multiple filter expressions using logical OR.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>List[Union[Filter, Token]]</code> <p>A list of filters and OR tokens.</p> required <p>Returns:</p> Type Description <code>Filter</code> <p>The combined filter expression.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def expr(self, args: List[Union[Filter, Token]]) -&gt; Filter:\n    \"\"\"\n    Combine multiple filter expressions using logical OR.\n\n    Args:\n        args: A list of filters and OR tokens.\n\n    Returns:\n        The combined filter expression.\n    \"\"\"\n    return reduce(operator.or_, [item for item in args if not isinstance(item, Token)])\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterTransformer.factor","title":"<code>factor(args)</code>","text":"<p>Process a single filter or its negation.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>List[Union[Filter, Token]]</code> <p>A list containing a single filter and an optional token for its negation.</p> required <p>Returns:</p> Type Description <code>Filter</code> <p>The processed filter.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def factor(self, args: List[Union[Filter, Token]]) -&gt; Filter:\n    \"\"\"\n    Process a single filter or its negation.\n\n    Args:\n        args: A list containing a single filter and an optional token for its negation.\n\n    Returns:\n        The processed filter.\n    \"\"\"\n    if len(args) == 1:\n        return args[0]\n    elif len(args) == 2:\n        return -cast(Filter, args[1])\n    msg = f\"Unexpected token sequence: {args}.\"\n    raise ValueError(msg)\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterTransformer.identifier","title":"<code>identifier(args)</code>","text":"<p>Resolves and validates an identifier token, updating its value based on field type.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>List[Token]</code> <p>A list of tokens containing identifier details.</p> required <p>Returns:</p> Type Description <code>Token</code> <p>The updated token with resolved field information.</p> <p>Raises:</p> Type Description <code>SemanticError</code> <p>If the field is invalid or unsupported.</p> <code>ValueError</code> <p>If an unexpected token sequence is provided.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def identifier(self, args: List[Token]) -&gt; Token:\n    \"\"\"\n    Resolves and validates an identifier token, updating its value based on field type.\n\n    Args:\n        args: A list of tokens containing identifier details.\n\n    Returns:\n        The updated token with resolved field information.\n\n    Raises:\n        SemanticError: If the field is invalid or unsupported.\n        ValueError: If an unexpected token sequence is provided.\n    \"\"\"\n    if len(args) == 1:\n        field = args[0].value\n        if field.startswith(\"options.\"):\n            option_field = field[8:]\n            if not self._options_fields:\n                msg = f\"{self._obj.__name__.capitalize()} fillers don't have options fields.\"\n                raise SemanticError(\n                    msg=msg,\n                    expr=self._expr,\n                    column=args[0].column,\n                )\n            if (\n                option_field not in TaskOptionFilter._fields\n                or TaskOptionFilter._fields[option_field][0] == FType.NA\n                or TaskOptionFilter._fields[option_field][0] == FType.UNKNOWN\n            ):\n                msg = f\"{self._obj.__name__.capitalize()} fillers don't have a field '{option_field}' in the option fields.\"\n                raise SemanticError(\n                    msg=msg,\n                    expr=self._expr,\n                    column=args[0].column,\n                )\n            return args[0].update(value=(field, getattr(self._obj.options, option_field)))\n        elif field.startswith(\"output.\"):\n            output_field = field[7:]\n            if not self._output_fields:\n                msg = f\"{self._obj.__name__.capitalize()} fillers don't have output fields.\"\n                raise SemanticError(\n                    msg=msg,\n                    expr=self._expr,\n                    column=args[0].column,\n                )\n            if output_field != \"error\":\n                msg = f\"{self._obj.__name__.capitalize()} fillers don't have a field '{output_field}' in the output fields.\"\n                raise SemanticError(\n                    msg=msg,\n                    expr=self._expr,\n                    column=args[0].column,\n                )\n            return args[0].update(value=(field, getattr(self._obj.output, output_field)))\n        if (\n            field not in self._filter._fields\n            or self._filter._fields[field][0] == FType.NA\n            or self._filter._fields[field][0] == FType.UNKNOWN\n        ):\n            msg = f\"{self._obj.__name__.capitalize()} filters don't have a field '{field}'.\"\n            raise SemanticError(\n                msg=msg,\n                expr=self._expr,\n                column=args[0].column,\n            )\n        return args[0].update(value=(field, getattr(self._obj, field)))\n    elif len(args) == 3:\n        key = args[1].value\n        if not self._options_fields:\n            msg = f\"{self._obj.__name__.capitalize()} fillers have no options fields and therefore no custom option fields..\"\n            raise SemanticError(\n                msg=msg,\n                expr=self._expr,\n                column=args[0].column,\n            )\n        return args[1].update(value=(f\"option['{key}']\", self._obj.options[key]))\n    msg = f\"Unexcepted token sequence: {args}.\"\n    raise ValueError(msg)\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterTransformer.term","title":"<code>term(args)</code>","text":"<p>Combine multiple filter expressions using logical AND.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>List[Union[Filter, Token]]</code> <p>A list of filters and AND tokens.</p> required <p>Returns:</p> Type Description <code>Filter</code> <p>The combined filter expression.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def term(self, args: List[Union[Filter, Token]]) -&gt; Filter:\n    \"\"\"\n    Combine multiple filter expressions using logical AND.\n\n    Args:\n        args: A list of filters and AND tokens.\n\n    Returns:\n        The combined filter expression.\n    \"\"\"\n    return reduce(operator.and_, [item for item in args if not isinstance(item, Token)])\n</code></pre>"},{"location":"code_docs_gen/#armonik_cli.core.filters.FilterTransformer.test","title":"<code>test(args)</code>","text":"<p>Process a test expression.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>List[Token]</code> <p>A list of tokens containing the field and filter data.</p> required <p>Returns:</p> Type Description <code>BooleanFilter</code> <p>The boolean filter extracted from the token.</p> <p>Raises:</p> Type Description <code>SemanticError</code> <p>If the field's filter is not a boolean field.</p> <code>ValueError</code> <p>If an unexpected token sequence is provided.</p> Source code in <code>venv/lib/python3.10/site-packages/armonik_cli/core/filters.py</code> <pre><code>def test(self, args: List[Token]) -&gt; BooleanFilter:\n    \"\"\"\n    Process a test expression.\n\n    Args:\n        args: A list of tokens containing the field and filter data.\n\n    Returns:\n        The boolean filter extracted from the token.\n\n    Raises:\n        SemanticError: If the field's filter is not a boolean field.\n        ValueError: If an unexpected token sequence is provided.\n    \"\"\"\n    if len(args) == 1:\n        field, filter = args[0].value\n        if isinstance(filter, BooleanFilter):\n            return filter\n        msg = f\"{self._obj.__name__.capitalize()} filter's '{field}' field is not a boolean field.\"\n        raise SemanticError(\n            msg=msg,\n            expr=self._expr,\n            column=args[0].column,\n        )\n    msg = f\"Unexcepted token sequence: {args}.\"\n    raise ValueError(msg)\n</code></pre>"},{"location":"development/","title":"Installing ArmoniK.Admin.CLI for development :","text":""},{"location":"development/#requirements","title":"Requirements","text":"<p>The CLI requires Python version 3.8 or newer. In order to install the ArmoniK CLI in an isolated environment, you must have python3-venv installed on your machine.</p> <pre><code>sudo apt update &amp;&amp; sudo apt install python3-venv\n</code></pre>"},{"location":"development/#installation","title":"Installation","text":"<p>To install the CLI from source, first clone this repository.</p> <pre><code>git clone git@github.com/aneoconsulting/ArmoniK.Admin.CLI.git\n</code></pre> <p>Navigate in the root directory</p> <pre><code>cd ArmoniK.Admin.CLI\n</code></pre> <p>Create and activate the virtual environment</p> <pre><code>python -m venv ./venv\nsource ./venv/bin/activate\n</code></pre> <p>Perform an editable install of the ArmoniK.Admin.CLI</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"development/#running-tests","title":"Running tests","text":"<p>We use pytest for unit tests</p> <pre><code>pytest tests/\n</code></pre>"},{"location":"development/#linting-and-formatting","title":"Linting and formatting","text":"<p>Install the development packages</p> <pre><code>pip install '.[dev]'\n</code></pre> <p>Formatting  <pre><code>ruff format\n</code></pre></p> <p>Linting <pre><code>ruff check . \n</code></pre></p>"},{"location":"development/#documentation","title":"Documentation","text":"<p>Install the documentation packages</p> <pre><code>pip install '.[docs]'\n</code></pre> <p>Serving the documentation locally  <pre><code>mkdocs serve\n</code></pre></p> <p>Publishing the documentation to github pages <pre><code>mkdocs gh-deploy\n</code></pre></p>"},{"location":"usage/","title":"Usage","text":"<p><code>armonik -h</code> is your friend.</p>"}]}